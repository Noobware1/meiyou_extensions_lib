import 'package:meiyou_extensions_lib/src/lib_overrides.dart';
import 'package:meiyou_extensions_lib/src/models/content_data.dart';
import 'package:meiyou_extensions_lib/src/models/content_data_link.dart';
import 'package:meiyou_extensions_lib/src/models/filter_list.dart';
import 'package:meiyou_extensions_lib/src/models/home_page.dart';
import 'package:meiyou_extensions_lib/src/models/info_page.dart';
import 'package:meiyou_extensions_lib/src/models/search_page.dart';
import 'package:meiyou_extensions_lib/src/models/source/catalogue_source.dart';
import 'package:meiyou_extensions_lib/src/network/network_helper.dart';
import 'package:meiyou_extensions_lib/src/utils/utils.dart';
import 'package:meta/meta.dart';
import 'package:okhttp/okhttp.dart';
import 'package:okhttp/request.dart';
import 'package:okhttp/response.dart';

abstract class HttpSource extends CatalogueSource {
  HttpSource();

  /// Network service.
  @protected
  final NetworkHelper network = ExtensionlibOverrides.networkHelper;

  /// Base url of the website without the trailing slash, like: http://mysite.com
  abstract final String baseUrl;

  final int versionId = 1;

  // /// ID of the source. By default it uses a generated id using the first 16 characters (64 bits)
  // /// of the MD5 of the string `"${name.lowercase()}/$lang/$versionId"`.
  // ///
  // /// The ID is generated by the [generateId] function, which can be reused if needed
  // /// to generate outdated IDs for cases where the source name or language needs to
  // /// be changed but migrations can be avoided.
  // ///
  // /// Note: the generated ID sets the sign bit to `0`.
  @override
  late final int id = generateId(name, lang, versionId);

  /// Headers used for requests.
  late final Headers headers = headersBuilder().build();

  OkHttpClient get client => network.client;

  // /// Generates a unique ID for the source based on the provided [name], [lang] and
  // /// [versionId]. It will use the first 16 characters (64 bits) of the MD5 of the string
  // /// `"${name.lowercase()}/$lang/$versionId"`.
  // ///
  // /// Note: the generated ID sets the sign bit to `0`.
  // ///
  // /// Can be used to generate outdated IDs, such as when the source name or language
  // /// needs to be changed but migrations can be avoided.
  // ///
  // /// @param name [String] the name of the source
  // /// @param lang [String] the language of the source
  // /// @param versionId [Int] the version ID of the source
  // /// @return a unique ID for the source
  // int _generateId(String name, String lang, int versionId) {
  //   final key = "${name.toLowerCase()}/$lang/$versionId";
  //   final bytes = MD5(key.codeUnits).bytes;
  //   return List.generate(
  //               8, (index) => (bytes[index] & 0xFF) << (8 * (7 - index)))
  //           .reduce((value, element) => value | element) &
  //       0x7FFFFFFFFFFFFFFF;
  // }

  /// Headers builder for requests. Implementations can override this method for custom headers.
  HeadersBuilder headersBuilder() =>
      Headers.Builder().add('User-Agent', network.defaultUserAgentProvider);

  @override
  Future<HomePage> getHomePage(int page, HomePageRequest request) {
    return client
        .newCall(homePageRequest(page, request))
        .execute()
        .then((response) => homePageParse(request, response));
  }

  /// Returns the request for the popular manga given the page.
  ///
  /// * page the page number to retrieve.
  Request homePageRequest(int page, HomePageRequest request);

  /// Parses the response from the site and returns a [MangasPage] object.
  ///
  /// * response the response from the site.
  HomePage homePageParse(HomePageRequest request, Response response);

  @override
  Future<SearchPage> getSearchPage(int page, String query, FilterList filters) {
    return client
        .newCall(searchPageRequest(page, query, filters))
        .execute()
        .then((response) => searchPageParse(response));
  }

  /// Returns the request for the search manga given the page.
  ///
  /// * page the page number to retrieve.
  Request searchPageRequest(int page, String query, FilterList filters);

  /// Parses the response from the site and returns a [SearchResponse] object.
  ///
  /// * response the response from the site.
  SearchPage searchPageParse(Response response);

  @override
  Future<InfoPage> getInfoPage(String url) {
    return client
        .newCall(infoPageRequest(url))
        .execute()
        .then((response) => infoPageParse(response));
  }

  Request infoPageRequest(String url);

  Future<InfoPage> infoPageParse(Response response);

  @override
  Future<List<ContentDataLink>> getContentDataLinks(String url) {
    return client
        .newCall(contentDataLinksRequest(url))
        .execute()
        .then((response) => contentDataLinksParse(response));
  }

  Request contentDataLinksRequest(String url);

  List<ContentDataLink> contentDataLinksParse(Response response);

  @override
  Future<ContentData?> getContentData(ContentDataLink link) {
    try {
      return client
          .newCall(contentDataRequest(link))
          .execute()
          .then((response) => contentDataParse(response));
    } on UnsupportedError {
      return Future.value(null);
    } catch (e) {
      rethrow;
    }
  }

  Request contentDataRequest(ContentDataLink link) {
    return throw UnsupportedError('Not implemented');
  }

  Future<ContentData> contentDataParse(Response response) {
    return throw UnsupportedError('Not implemented');
  }
}
