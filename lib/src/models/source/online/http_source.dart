import 'package:meiyou_extensions_lib/network.dart';
import 'package:meiyou_extensions_lib/src/lib_overrides.dart';
import 'package:meiyou_extensions_lib/src/models/filter_list.dart';
import 'package:meiyou_extensions_lib/src/models/home_page.dart';
import 'package:meiyou_extensions_lib/src/models/media.dart';
import 'package:meiyou_extensions_lib/src/models/media_content.dart';
import 'package:meiyou_extensions_lib/src/models/media_details.dart';
import 'package:meiyou_extensions_lib/src/models/media_link.dart';
import 'package:meiyou_extensions_lib/src/models/search_page.dart';
import 'package:meiyou_extensions_lib/src/models/source/catalogue_source.dart';
import 'package:meiyou_extensions_lib/src/utils/utils.dart';
import 'package:meta/meta.dart';
import 'package:okhttp/okhttp.dart';
import 'package:okhttp/request.dart';
import 'package:okhttp/response.dart';

abstract class HttpSource extends CatalogueSource {
  HttpSource();

  /// Network service.
  @protected
  final NetworkHelper network = ExtensionlibOverrides.networkHelper;

  /// Base url of the website without the trailing slash, like: http://mysite.com
  abstract final String baseUrl;

  final int versionId = 1;

  // /// ID of the source. By default it uses a generated id using the first 16 characters (64 bits)
  // /// of the MD5 of the string `"${name.lowercase()}/$lang/$versionId"`.
  // ///
  // /// The ID is generated by the [generateId] function, which can be reused if needed
  // /// to generate outdated IDs for cases where the source name or language needs to
  // /// be changed but migrations can be avoided.
  // ///
  // /// Note: the generated ID sets the sign bit to `0`.
  @override
  late final int id = generateId(name, lang, versionId);

  /// Headers used for requests.
  late final Headers headers = headersBuilder().build();

  OkHttpClient get client => network.client;

  /// Headers builder for requests. Implementations can override this method for custom headers.
  HeadersBuilder headersBuilder() =>
      Headers.Builder().add('User-Agent', network.defaultUserAgentProvider);

  @override
  Future<HomePage> getHomePage(int page, HomePageRequest request) {
    return client.newCall(homePageRequest(page, request)).execute().then(
      (response) {
        try {
          return homePageParse(request, response);
        } on UnsupportedError {
          return homePageParseAsync(request, response);
        }
      },
    );
  }

  /// Returns the request for the popular manga given the page.
  ///
  /// * page the page number to retrieve.
  Request homePageRequest(int page, HomePageRequest request);

  /// Parses the response from the site and returns a [MangasPage] object.
  ///
  /// * response the response from the site.
  HomePage homePageParse(HomePageRequest request, Response response) {
    return throw UnsupportedError('Not implemented');
  }

  Future<HomePage> homePageParseAsync(
      HomePageRequest request, Response response) {
    throw UnsupportedError('Not implemented');
  }

  @override
  Future<SearchPage> getSearchPage(int page, String query, FilterList filters) {
    return client
        .newCall(searchPageRequest(page, query, filters))
        .execute()
        .then(
      (response) {
        try {
          return searchPageParse(response);
        } on UnsupportedError {
          return searchPageParseAsync(response);
        }
      },
    );
  }

  /// Returns the request for the search manga given the page.
  ///
  /// * page the page number to retrieve.
  Request searchPageRequest(int page, String query, FilterList filters);

  /// Parses the response from the site and returns a [SearchResponse] object.
  ///
  /// * response the response from the site.
  SearchPage searchPageParse(Response response) {
    return throw UnsupportedError('Not implemented');
  }

  Future<SearchPage> searchPageParseAsync(Response response) {
    throw UnsupportedError('Not implemented');
  }

  @override
  Future<MediaDetails> getMediaDetails(MediaDetails mediaDetails) {
    return client.newCall(mediaDetailsRequest(mediaDetails)).execute().then(
      (response) {
        try {
          return mediaDetailsParse(response);
        } on UnsupportedError {
          return mediaDetailsParseAsync(response);
        }
      },
    );
  }

  Request mediaDetailsRequest(MediaDetails mediaDetails) {
    return GET(baseUrl + mediaDetails.url, headers: headers);
  }

  MediaDetails mediaDetailsParse(Response response) {
    return throw UnsupportedError('Not implemented');
  }

  Future<MediaDetails> mediaDetailsParseAsync(Response response) {
    throw UnsupportedError('Not implemented');
  }

  @override
  Future<MediaContent> getMediaContent(MediaDetails mediaDetails) {
    return client.newCall(mediaContentRequest(mediaDetails)).execute().then(
      (response) {
        try {
          return mediaContentParse(response);
        } on UnsupportedError {
          return mediaContentParseAsync(response);
        }
      },
    );
  }

  Request mediaContentRequest(MediaDetails mediaDetails) {
    return GET(baseUrl + mediaDetails.url, headers: headers);
  }

  MediaContent mediaContentParse(Response response) {
    return throw UnsupportedError('Not implemented');
  }

  Future<MediaContent> mediaContentParseAsync(Response response) {
    throw UnsupportedError('Not implemented');
  }

  @override
  Future<List<MediaLink>> getMediaLinks(String data) {
    return client.newCall(mediaLinksRequest(data)).execute().then(
      (response) {
        try {
          return medialinksParse(response);
        } on UnsupportedError {
          return medialinksParseAsync(response);
        }
      },
    );
  }

  Request mediaLinksRequest(String data) {
    return GET(data, headers: headers);
  }

  List<MediaLink> medialinksParse(Response response) {
    return throw UnsupportedError('Not implemented');
  }

  Future<List<MediaLink>> medialinksParseAsync(Response response) {
    throw UnsupportedError('Not implemented');
  }

  @override
  Future<Media?> getMedia(MediaLink link) {
    try {
      return client
          .newCall(mediaRequest(link))
          .execute()
          .then((response) => mediaParse(response));
    } on UnsupportedError {
      return Future.value(null);
    } catch (e) {
      rethrow;
    }
  }

  Request mediaRequest(MediaLink link) {
    return GET(link.data, headers: headers);
  }

  Media? mediaParse(Response response) {
    return throw UnsupportedError('Not implemented');
  }
}
