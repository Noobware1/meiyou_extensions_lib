import 'package:crypto_dart/hashers.dart';
import 'package:meiyou_extensions_lib/src/models/extractor_link.dart';
import 'package:meiyou_extensions_lib/src/models/filter_list.dart';
import 'package:meiyou_extensions_lib/src/models/homepage.dart';
import 'package:meiyou_extensions_lib/src/models/interfaces/catalogue_source.dart';
import 'package:meiyou_extensions_lib/src/models/media/media.dart';
import 'package:meiyou_extensions_lib/src/models/media_details.dart';
import 'package:meiyou_extensions_lib/src/models/search_response.dart';
import 'package:meiyou_extensions_lib/src/network/network_helper.dart';
import 'package:okhttp/okhttp.dart';
import 'package:okhttp/request.dart';
import 'package:okhttp/response.dart';

abstract class HttpSource extends CatalogueSource {
  HttpSource(this.network);

  /// Network service.
  final NetworkHelper network;

  /// Base url of the website without the trailing slash, like: http://mysite.com
  abstract final String baseUrl;

  final int versionId = 1;

  // /// ID of the source. By default it uses a generated id using the first 16 characters (64 bits)
  // /// of the MD5 of the string `"${name.lowercase()}/$lang/$versionId"`.
  // ///
  // /// The ID is generated by the [generateId] function, which can be reused if needed
  // /// to generate outdated IDs for cases where the source name or language needs to
  // /// be changed but migrations can be avoided.
  // ///
  // /// Note: the generated ID sets the sign bit to `0`.
  @override
  late final int id = _generateId(name, lang, versionId);

  int _generateId(String name, String lang, int versionId) {
    final key = "${name.toLowerCase()}/$lang/$versionId";
    final bytes = MD5(key.codeUnits).bytes;
    return List.generate(
                8, (index) => (bytes[index] & 0xFF) << (8 * (7 - index)))
            .reduce((value, element) => value | element) &
        0x7FFFFFFFFFFFFFFF;
  }

  /// Headers used for requests.
  late final Headers headers = headersBuilder().build();

  OkHttpClient get client => network.client;

  // /// Generates a unique ID for the source based on the provided [name], [lang] and
  // /// [versionId]. It will use the first 16 characters (64 bits) of the MD5 of the string
  // /// `"${name.lowercase()}/$lang/$versionId"`.
  // ///
  // /// Note: the generated ID sets the sign bit to `0`.
  // ///
  // /// Can be used to generate outdated IDs, such as when the source name or language
  // /// needs to be changed but migrations can be avoided.
  // ///
  // /// @param name [String] the name of the source
  // /// @param lang [String] the language of the source
  // /// @param versionId [Int] the version ID of the source
  // /// @return a unique ID for the source
  // int _generateId(String name, String lang, int versionId) {
  //   final key = "${name.toLowerCase()}/$lang/$versionId";
  //   final bytes = MD5(key.codeUnits).bytes;
  //   return List.generate(
  //               8, (index) => (bytes[index] & 0xFF) << (8 * (7 - index)))
  //           .reduce((value, element) => value | element) &
  //       0x7FFFFFFFFFFFFFFF;
  // }

  /// Headers builder for requests. Implementations can override this method for custom headers.
  HeadersBuilder headersBuilder() =>
      Headers.Builder().add('User-Agent', network.defaultUserAgentProvider);

  /// Returns the request for the popular manga given the page.
  ///
  /// * page the page number to retrieve.
  Request homePageRequest(int page, HomePageRequest request);

  /// Parses the response from the site and returns a [MangasPage] object.
  ///
  /// * response the response from the site.
  HomePage homePageParse(int page, HomePageRequest request, Response response);

  @override
  Future<HomePage> getHomePage(int page, HomePageRequest request) {
    return client
        .newCall(homePageRequest(page, request))
        .execute()
        .then((response) => homePageParse(page, request, response));
  }

  /// Returns the request for the search manga given the page.
  ///
  /// * page the page number to retrieve.
  Request searchRequest(int page, String query, FilterList filters);

  /// Parses the response from the site and returns a [SearchResponse] object.
  ///
  /// * response the response from the site.
  List<SearchResponse> searchParse(Response response);

  @override
  Future<List<SearchResponse>> getSearch(
      int page, String query, FilterList filters) {
    return client
        .newCall(searchRequest(page, query, filters))
        .execute()
        .then((response) => searchParse(response));
  }

  /// Returns the request for the media details given the media.
  ///
  /// * searchResponse the searchResponse of the media.
  Request mediaDetailsRequest(SearchResponse searchResponse);

  /// Parses the response from the site and returns a `SearchResponse` object.
  ///
  /// * response the response from the site.
  MediaDetails mediaDetailsParse(Response response);

  @override
  Future<MediaDetails> getMediaDetails(SearchResponse searchResponse) {
    return client
        .newCall(mediaDetailsRequest(searchResponse))
        .execute()
        .then((response) => mediaDetailsParse(response));
  }

  /// Returns the request for the links given the url.
  ///
  /// * url the url of the media.
  Request linksRequest(String url);

  /// Parses the response from the site and returns a `List<ExtractorLinks>` object.
  ///
  /// * response the response from the site.
  List<ExtractorLink> linksParse(Response response);

  @override
  Future<List<ExtractorLink>> getLinks(String url) {
    return client
        .newCall(linksRequest(url))
        .execute()
        .then((response) => linksParse(response));
  }

  /// Returns the request for the media given the link.
  ///
  /// * link the link of the media.
  Request? mediaRequest(ExtractorLink link);

  /// Parses the response from the site and returns a `Media` object.
  ///
  /// * response the response from the site.
  Media? mediaParse(Response response);

  @override
  Future<Media?> getMedia(ExtractorLink link) {
    final request = mediaRequest(link);
    if (request == null) {
      return Future.value(null);
    }
    return client
        .newCall(request)
        .execute()
        .then((response) => mediaParse(response));
  }
}
